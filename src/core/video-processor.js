class VideoProcessor {
  constructor(languageDetector) {
    this.languageDetector = languageDetector;
    this.processedVideos = new Set();
    this.filteredVideos = []; // üÜï Filtrelenen videolarƒ± toplama listesi
    this.maxListSize = 50; // Maksimum liste boyutu
    this.naturalProcessQueue = []; // üÜï Natural i≈ülem kuyruƒüu
  }

  getVideoElements() {
    // Sadece ger√ßek video i√ßeriƒüi olan selekt√∂rler
    const selectors = [
      // Ana video content selekt√∂rleri
      'ytd-video-renderer',          // ‚úÖ Arama sonu√ßlarƒ± (17 element)
      'ytd-rich-item-renderer',      // Ana sayfa videolarƒ±
      'ytd-grid-video-renderer',     // Grid g√∂r√ºn√ºm√º
      'ytd-compact-video-renderer',  // Kompakt g√∂r√ºn√ºm
      'ytd-movie-renderer',          // Film i√ßerikleri
      'ytd-playlist-renderer',       // Playlist'ler
      'ytd-radio-renderer',          // Mix'ler
      'ytd-rich-grid-media',        // Shorts grid
      'yt-lockup-view-model',      // hem shorts hem playlist 

      'ytd-rich-section-renderer',   // Shorts containers
      'ytm-shorts-lockup-view-model-v2', // Shorts containers
      
      // ƒ∞√ßerik t√ºrleri
      'ytd-channel-renderer'         // ‚úÖ Kanal sonu√ßlarƒ± (1 element)
      
    ];
    
    let videos = [];
    for (const selector of selectors) {
      const found = Array.from(document.querySelectorAll(selector));
      if (found.length > 0) {
        console.log(`üìã Found ${found.length} ${selector} elements`);
        videos = videos.concat(found);
      }
    }
    
    // Reklam elementlerini filtrele
    videos = videos.filter(video => !this.isStrictAdElement(video));
    
    videos = [...new Set(videos)];
    console.log(`üé¨ Found ${videos.length} total video elements`);
    return videos;
  }

  // Daha spesifik ad filter
  isStrictAdElement(element) {
    // Sadece kesin reklam elementlerini filtrele
    const strictAdSelectors = [
      'ytd-ad-slot-renderer',
      'ytd-in-feed-ad-layout-renderer'
    ];
    
    return strictAdSelectors.some(selector => 
      element.matches(selector) || element.closest(selector)
    );
  }

  isAdElement(element) {
    const adSelectors = [
      'ytd-ad-slot-renderer',
      'ytd-in-feed-ad-layout-renderer',
      '[data-is-ad="true"]'
    ];
    
    return adSelectors.some(selector => 
      element.matches(selector) || 
      element.closest(selector) ||
      element.querySelector(selector)
    );
  }

  // üÜï Filtrelenen video ekle
  addToFilteredList(videoData) {
    const item = {
      title: videoData.title,
      language: videoData.language,
      type: videoData.type || 'VIDEO',
      timestamp: new Date().toLocaleTimeString(),
      url: videoData.url || null,
      element: videoData.element || null, // üÜï DOM elementi referansƒ±
      channelName: videoData.channelName || null // üÜï Kanal adƒ±
    };
    
    // Listeye ekle (en yeniler √ºstte)
    this.filteredVideos.unshift(item);
    
    // Maksimum boyutu a≈ü
    if (this.filteredVideos.length > this.maxListSize) {
      this.filteredVideos = this.filteredVideos.slice(0, this.maxListSize);
    }
    
    // Console'da g√∂ster (mevcut davranƒ±≈ü)
    console.log(`üö´ Filtered: [${videoData.language}] ${videoData.title}`);
    
    // Storage'a kaydet
    this.saveFilteredVideos();
  }

  // üÜï Storage'a filtrelenen videolarƒ± kaydet
  async saveFilteredVideos() {
    try {
      await chrome.storage.local.set({
        'filteredVideos': this.filteredVideos,
        'lastUpdate': Date.now()
      });
    } catch (error) {
      console.error('Error saving filtered videos:', error);
    }
  }

  // üÜï Filtrelenen videolarƒ± temizle
  async clearFilteredVideos() {
    this.filteredVideos = [];
    await this.saveFilteredVideos();
  }

  // üÜï Video URL'sini √ßƒ±kar
  extractVideoUrl(videoElement) {
    const linkSelectors = [
      'a[href*="/watch"]',
      'a[href*="/shorts/"]', 
      'a[href*="/playlist"]',
      'a[href*="/channel/"]',
      'a[href*="/@"]'
    ];
    
    for (const selector of linkSelectors) {
      const link = videoElement.querySelector(selector);
      if (link && link.href) {
        return link.href;
      }
    }
    return null;
  }

  // üÜï Video elementinden kanal adƒ±nƒ± √ßƒ±kar
  extractChannelName(videoElement) {
    const channelSelectors = [
      'ytd-channel-name a',
      '#channel-name a',
      '.ytd-channel-name a',
      '[id="channel-name"] a',
      'a[href*="/channel/"]',
      'a[href*="/@"]',
      '.yt-simple-endpoint.style-scope.yt-formatted-string'
    ];
    
    for (const selector of channelSelectors) {
      const element = videoElement.querySelector(selector);
      if (element && element.textContent && element.textContent.trim()) {
        return element.textContent.trim();
      }
    }
    return null;
  }

  async processVideo(videoElement, isEnabled) {
    if (this.processedVideos.has(videoElement)) return;
    
    this.processedVideos.add(videoElement);
    
    // Reklam kontrol√º
    if (this.isAdElement(videoElement)) {
      videoElement.style.display = 'none';
      return;
    }

    // ‚ú® Hi√ß g√∂r√ºnmeme garantisi
    videoElement.classList.add('yef-processing');
    
    const videoData = this.extractVideoData(videoElement);
    
    if (videoData && videoData.title) {
      const language = await this.languageDetector.detectLanguage(videoData.title);
      const url = this.extractVideoUrl(videoElement);
      const channelName = this.extractChannelName(videoElement);
      
      // ‚ö° Anƒ±nda karar ver ve g√∂ster/gizle
      if (isEnabled && language !== 'en') {
        this.hideVideo(videoElement, language);
        
        // üÜï Element referansƒ± da ekle
        this.addToFilteredList({
          title: videoData.title,
          language: language,
          type: videoData.type,
          url: url,
          element: videoElement,
          channelName: channelName
        });
      } else {
        this.showVideo(videoElement, language);
      }
      
      this.markVideoAsProcessed(videoElement, language);
    } else {
      // Ba≈ülƒ±k yoksa gizle
      this.hideVideo(videoElement, 'unknown');
      this.markVideoAsProcessed(videoElement, 'unknown');
    }
  }

  extractVideoData(videoElement) {
    const contentType = this.getContentType(videoElement);
    
    // Kanal sonu√ßlarƒ± i√ßin √∂zel handling
    if (videoElement.tagName === 'YTD-CHANNEL-RENDERER') {
      return this.extractChannelData(videoElement);
    }
    
    // üÜï YENƒ∞: yt-formatted-string prioritesi ile
    const titleSelectors = [
      'yt-formatted-string[id="video-title"]',  // üÜï En spesifik
      'yt-formatted-string#video-title',        // üÜï Alternatif yazƒ±m
      '[title]',                                // ‚úÖ √áalƒ±≈üƒ±yor
      '#video-title',                           // ‚úÖ √áalƒ±≈üƒ±yor  
      'a#video-title',                          // ‚úÖ √áalƒ±≈üƒ±yor
      'h3',                          
      '#video-title-link',
      'h3 a[href*="/watch"]',
      'a[href*="/watch"] h3',
      'span[dir="auto"]',
      'a[href*="/shorts/"]',
      'a[href*="/playlist"] h3'
    ];
    
    let title = '';
    for (const selector of titleSelectors) {
      const element = videoElement.querySelector(selector);
      if (element) {
        title = element.textContent?.trim() || 
                element.getAttribute('title')?.trim() || '';
        
        if (title && title.length > 2) {
          console.log(`üìù Title found with selector: ${selector} -> "${title.substring(0, 50)}..."`);
          break;
        }
      }
    }
    
    if (title) {
      title = this.cleanTitle(title);
    }
    
    return title && title.length > 3 ? { title, type: contentType } : null;
  }

  // Yeni metod ekle
  extractChannelData(channelElement) {
    const channelSelectors = [
      'ytd-channel-name a',
      '#text',
      '#channel-title',
      'yt-formatted-string',
      'a[href*="/channel/"]',
      'a[href*="/@"]'
    ];
    
    for (const selector of channelSelectors) {
      const element = channelElement.querySelector(selector);
      if (element) {
        const text = element.textContent?.trim();
        if (text && text.length > 2) {
          console.log(`üìù Channel title found: "${text}"`);
          return { title: text, type: 'CHANNEL' };
        }
      }
    }
    
    return null;
  }

  getContentType(videoElement) {
    // Kanal kontrol√º ekle
    if (videoElement.tagName === 'YTD-CHANNEL-RENDERER') {
      return 'CHANNEL';
    }
    
    // Shorts kontrol√º
    if (videoElement.querySelector('a[href*="/shorts/"]')) {
      return 'SHORTS';
    }
    
    // Playlist kontrol√º
    if (videoElement.querySelector('a[href*="/playlist"]') || 
        videoElement.tagName === 'YTD-PLAYLIST-RENDERER' ||
        videoElement.tagName === 'YTD-RADIO-RENDERER') {
      return 'PLAYLIST';
    }
    
    // Mix kontrol√º
    if (videoElement.querySelector('a[href*="/watch"][href*="&list="]')) {
      return 'MIX';
    }
    
    return 'VIDEO';
  }

  cleanTitle(title) {
    // Zaman damgalarƒ±nƒ± temizle
    title = title.replace(/\s*\(\d+:\d+\)\s*/g, '').trim();
    
    // Fazla bo≈üluklarƒ± temizle
    title = title.replace(/\s+/g, ' ').trim();
    
    // YouTube artifacts temizle
    title = title.replace(/^(Mix ‚Äì |Mix - )/i, '').trim();
    title = title.replace(/\s*\|\s*YouTube\s*$/i, '').trim();
    
    return title;
  }

  // ‚ú® YENƒ∞: CSS class-based hide/show
  hideVideo(videoElement, language = 'non-en') {
    videoElement.classList.remove('yef-english', 'yef-processing');
    videoElement.classList.add('yef-hidden');
    videoElement.setAttribute('data-filtered', 'true');
    videoElement.setAttribute('data-language', language);
  }

  showVideo(videoElement, language = 'en') {
    videoElement.classList.remove('yef-hidden', 'yef-processing');
    videoElement.classList.add('yef-english');
    videoElement.removeAttribute('data-filtered');
    videoElement.setAttribute('data-language', language);
  }

  markVideoAsProcessed(videoElement, language) {
    videoElement.setAttribute('data-processed', 'true');
    videoElement.setAttribute('data-language', language);
  }

  // ‚ú® YENƒ∞: Geli≈ütirilmi≈ü reprocess
  reprocessAllVideos(isEnabled) {
    // Body'ye filter durumunu ekle
    if (isEnabled) {
      document.body.classList.remove('yef-filter-disabled');
    } else {
      document.body.classList.add('yef-filter-disabled');
    }

    const videos = this.getVideoElements();
    videos.forEach(video => {
      const language = video.getAttribute('data-language');
      if (language) {
        if (isEnabled && language !== 'en' && language !== 'unknown') {
          this.hideVideo(video, language);
        } else {
          this.showVideo(video, language);
        }
      }
    });
  }

  // üÜï Video elementinin tipini ve yapƒ±sƒ±nƒ± analiz et (Shorts destekli)
  analyzeVideoElement(videoElement) {
    const analysis = {
      tagName: videoElement.tagName,
      classes: Array.from(videoElement.classList),
      location: this.getPageLocation(),
      hasMenuButton: false,
      menuButtonSelectors: [],
      videoType: this.getContentType(videoElement)
    };
    
    // Video tipi bazƒ±nda farklƒ± men√º buton kontrol√º
    let menuSelectors = [];
    
    if (analysis.videoType === 'SHORTS') {
      // Shorts i√ßin √∂zel selector'lar
      menuSelectors = [
        'yt-icon-button[aria-label*="More"]',
        'button[aria-label*="More actions"]', 
        'button[aria-label*="Actions"]',
        '.ytd-shorts-video-actions button[aria-label*="More"]',
        '.ytd-reel-video-renderer button[aria-label*="More"]',
        'ytd-shorts-player-controls button[aria-label*="More"]',
        '.shorts-video-actions button',
        '.ytd-shorts-video-actions yt-icon-button'
      ];
    } else {
      // Normal videolar i√ßin mevcut selector'lar
      menuSelectors = [
        'button[aria-label*="menu"]',
        'button[aria-label*="Menu"]', 
        'button[aria-label*="More"]',
        'button[aria-label*="more"]',
        'button[aria-label*="Action"]',
        'button[aria-label*="Options"]',
        'yt-icon-button[aria-label*="More"]',
        'ytd-menu-renderer button',
        '#button[aria-label*="More"]',
        '.ytd-menu-renderer button',
        '[role="button"][aria-label*="More"]'
      ];
    }
    
    for (const selector of menuSelectors) {
      const button = videoElement.querySelector(selector);
      if (button) {
        analysis.hasMenuButton = true;
        analysis.menuButtonSelectors.push({
          selector,
          ariaLabel: button.getAttribute('aria-label'),
          classes: Array.from(button.classList)
        });
      }
    }
    
    // Shorts i√ßin parent container'larda da ara
    if (analysis.videoType === 'SHORTS' && !analysis.hasMenuButton) {
      const parentContainers = [
        videoElement.closest('ytd-reel-video-renderer'),
        videoElement.closest('.ytd-shorts-video'),
        videoElement.closest('#shorts-container')
      ];
      
      for (const container of parentContainers) {
        if (container) {
          for (const selector of menuSelectors) {
            const button = container.querySelector(selector);
            if (button) {
              analysis.hasMenuButton = true;
              analysis.menuButtonSelectors.push({
                selector: `parent: ${selector}`,
                ariaLabel: button.getAttribute('aria-label'),
                classes: Array.from(button.classList)
              });
              break;
            }
          }
          if (analysis.hasMenuButton) break;
        }
      }
    }
    
    return analysis;
  }

  // üÜï Sayfa lokasyonunu tespit et
  getPageLocation() {
    const url = window.location.href;
    if (url.includes('/results?')) return 'search';
    if (url.includes('/watch?')) return 'watch';
    if (url.includes('/channel/') || url.includes('/@')) return 'channel';
    if (url.includes('/shorts/')) return 'shorts';
    if (url === 'https://www.youtube.com/' || url.includes('/feed/')) return 'home';
    return 'unknown';
  }

  // üÜï Shorts i√ßin √∂zel men√º butonu bulma
  async findMenuButtonForShorts(videoElement) {
    console.log('ü©≥ Shorts video detected, using special selectors...');
    const shortsMenuSelectors = [
      'yt-icon-button[aria-label*="More"]',
      'button[aria-label*="More actions"]',
      'button[aria-label*="Actions"]',
      '.ytd-shorts-video-actions button[aria-label*="More"]',
      '.ytd-reel-video-renderer button[aria-label*="More"]',
      'ytd-shorts-player-controls button[aria-label*="More"]',
      '.shorts-video-actions button',
      '.ytd-shorts-video-actions yt-icon-button',
      '#shorts-container button[aria-label*="More"]',
      '.reel-video-in-sequence button[aria-label*="More"]',
      'ytd-reel-video-renderer yt-icon-button',
      '.ytd-reel-video-renderer button[role="button"]',
      // Ek alternatifler
      'button[aria-label*="Diƒüer"]',
      'button[aria-label*="Men√º"]',
      'button[aria-label*="Se√ßenekler"]',
      '.ytd-shorts-video-actions button',
      '.ytd-shorts-video-actions yt-icon-button',
      '.ytd-reel-video-renderer button',
      '.ytd-reel-video-renderer yt-icon-button',
    ];
    // Retry ve bekleme ile men√º bulma
    for (let attempt = 0; attempt < 3; attempt++) {
      for (const selector of shortsMenuSelectors) {
        const button = videoElement.querySelector(selector);
        if (button) {
          console.log(`‚úÖ Shorts menu button found: ${selector} (${button.getAttribute('aria-label')}) [attempt ${attempt+1}]`);
          return button;
        }
      }
      // Parent container'larda da ara
      const parentContainers = [
        videoElement.closest('ytd-reel-video-renderer'),
        videoElement.closest('.ytd-shorts-video'),
        videoElement.closest('#shorts-container'),
        videoElement.closest('.shorts-video-container')
      ];
      for (const container of parentContainers) {
        if (container) {
          for (const selector of shortsMenuSelectors) {
            const button = container.querySelector(selector);
            if (button) {
              console.log(`‚úÖ Shorts menu button found in parent: ${selector} [attempt ${attempt+1}]`);
              return button;
            }
          }
        }
      }
      // Bulamazsa bekle ve tekrar dene
      await this.delay(800);
    }
    console.log('‚ùå No Shorts menu button found after retries');
    return null;
  }

  // üÜï Geli≈ütirilmi≈ü men√º butonu bulma (Shorts destekli)
  async findMenuButton(videoElement) {
    const analysis = this.analyzeVideoElement(videoElement);
    console.log('üîç Video Analysis:', analysis);
    
    // Eƒüer Shorts ise √∂zel metod kullan
    if (analysis.videoType === 'SHORTS') {
      return await this.findMenuButtonForShorts(videoElement);
    }
    
    // Normal videolar i√ßin mevcut kod
    const location = analysis.location;
    let selectors = [];
    
    if (location === 'home') {
      selectors = [
        'ytd-menu-renderer button',
        'yt-icon-button[aria-label*="More"]',
        'button[aria-label*="More actions"]',
        '#button[aria-label*="More"]'
      ];
    } else if (location === 'search') {
      selectors = [
        'button[aria-label*="More"]',
        'button[aria-label*="menu"]',
        'ytd-menu-renderer button',
        '.ytd-menu-renderer button'
      ];
    } else {
      // Genel selectors
      selectors = [
        'button[aria-label*="More"]',
        'button[aria-label*="menu"]',
        'button[aria-label*="Menu"]',
        'button[aria-label*="Action"]',
        'yt-icon-button[aria-label*="More"]',
        'ytd-menu-renderer button',
        '[role="button"][aria-label*="More"]'
      ];
    }
    
    for (const selector of selectors) {
      const button = videoElement.querySelector(selector);
      if (button) {
        console.log(`‚úÖ Menu button found: ${selector} (${button.getAttribute('aria-label')})`);
        return button;
      }
    }
    
    console.log('‚ùå No menu button found for:', analysis);
    return null;
  }

  // üÜï Shorts i√ßin √∂zel scroll ve visibility check
  async ensureShortsVisibility(videoElement) {
    // Shorts videolarƒ± i√ßin √∂zel g√∂r√ºn√ºrl√ºk kontrol√º
    const shortsContainer = videoElement.closest('ytd-reel-video-renderer') || 
                           videoElement.closest('.ytd-shorts-video') ||
                           videoElement.closest('#shorts-container');
    
    if (shortsContainer) {
      // Shorts container'ƒ±nƒ± merkeze getir
      shortsContainer.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'center',
        inline: 'center' 
      });
      
      await this.delay(1000);
      
      // Shorts'un aktif olduƒüundan emin ol
      const isActive = shortsContainer.querySelector('.html5-video-player video');
      if (isActive) {
        console.log('ü©≥ Shorts video is now active and visible');
        return true;
      }
    }
    
    return false;
  }

  // üÜï Shorts i√ßin √∂zel Natural i≈ülemler
  async performNotInterestedForShorts(videoElement) {
    try {
      console.log('ü©≥ Performing "Not interested" for Shorts...');
      
      // Shorts g√∂r√ºn√ºrl√ºƒü√ºn√º saƒüla
      await this.ensureShortsVisibility(videoElement);
      
      const menuButton = await this.findMenuButtonForShorts(videoElement);
      
      if (!menuButton) {
        console.log('‚ùå Shorts menu button not found');
        return false;
      }
      
      menuButton.click();
      console.log('üîò Shorts menu button clicked');
      
      // Shorts men√ºs√º genellikle farklƒ± yapƒ±da olur
      try {
        await this.waitForElement('[role="menuitem"], .ytd-menu-service-item-renderer, [role="option"]', 4000);
      } catch (error) {
        console.log('‚ùå Shorts menu items not loaded');
        document.body.click();
        return false;
      }
      
      const menuItems = Array.from(document.querySelectorAll('[role="menuitem"], [role="option"], .ytd-menu-service-item-renderer, .yt-dropdown-menu [role="button"]'));
      console.log('üîç Shorts menu items:', menuItems.map(item => item.textContent.trim()));
      
      // Shorts i√ßin "Not interested" metinleri
      const notInterestedTexts = [
        'Not interested',
        'not interested', 
        'ƒ∞lgilenmiyorum',
        'ilgilenmiyorum',
        "I'm not interested",
        'Hide this video',
        'Remove',
        'Hide'
      ];
      
      let notInterestedButton = null;
      for (const text of notInterestedTexts) {
        notInterestedButton = menuItems.find(item => 
          item.textContent.toLowerCase().includes(text.toLowerCase())
        );
        
        if (notInterestedButton) {
          console.log(`‚úÖ Shorts "Not interested" found: "${text}"`);
          break;
        }
      }
      
      if (notInterestedButton) {
        notInterestedButton.click();
        console.log('‚úÖ Shorts Not interested clicked successfully');
        await this.delay(500);
        return true;
      } else {
        console.log('‚ùå Shorts "Not interested" option not found');
        console.log('Available Shorts options:', menuItems.map(item => `"${item.textContent.trim()}"`));
        document.body.click();
        return false;
      }
      
    } catch (error) {
      console.error('‚ùå Shorts performNotInterested error:', error);
      try {
        document.body.click();
      } catch (e) {}
      return false;
    }
  }

  // üÜï Geli≈ütirilmi≈ü Natural i≈ülemler - ƒ∞lgilenmiyorum (Shorts destekli)
  async performNotInterested(videoElement) {
    const analysis = this.analyzeVideoElement(videoElement);
    
    // Eƒüer Shorts ise √∂zel metod kullan
    if (analysis.videoType === 'SHORTS') {
      return await this.performNotInterestedForShorts(videoElement);
    }
    
    // Normal videolar i√ßin mevcut kod
    try {
      const menuButton = await this.findMenuButton(videoElement);
      
      if (!menuButton) {
        console.log('‚ùå Menu button not found');
        return false;
      }
      
      // Scroll to element to ensure visibility
      videoElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
      await this.delay(500);
      
      menuButton.click();
      console.log('üîò Menu button clicked');
      
      // Men√º a√ßƒ±lana kadar bekle - daha uzun timeout
      try {
        await this.waitForElement('[role="menuitem"]', 4000);
      } catch (error) {
        console.log('‚ùå Menu items not loaded, trying alternative selectors...');
        // Alternatif men√º selectors
        const altSelectors = ['[role="menu"] [role="option"]', '.ytd-menu-service-item-renderer'];
        let found = false;
        for (const sel of altSelectors) {
          if (document.querySelector(sel)) {
            found = true;
            break;
          }
        }
        if (!found) {
          document.body.click(); // Men√ºy√º kapat
          return false;
        }
      }
      
      // Mevcut men√º √∂ƒüelerini listele (debug i√ßin)
      const menuItems = Array.from(document.querySelectorAll('[role="menuitem"], [role="option"], .ytd-menu-service-item-renderer'));
      console.log('üîç Menu items found:', menuItems.map(item => item.textContent.trim()));
      
      // "ƒ∞lgilenmiyorum" / "Not interested" se√ßeneƒüini bul
      const notInterestedTexts = [
        'Not interested',
        'not interested', 
        'ƒ∞lgilenmiyorum',
        'ilgilenmiyorum',
        "I'm not interested",
        'Hide this video',
        'Remove from recommendations',
        'Don\'t show me this'
      ];
      
      let notInterestedButton = null;
      for (const text of notInterestedTexts) {
        notInterestedButton = menuItems.find(item => 
          item.textContent.toLowerCase().includes(text.toLowerCase())
        );
        
        if (notInterestedButton) {
          console.log(`‚úÖ "Not interested" found: "${text}"`);
          break;
        }
      }
      
      if (notInterestedButton) {
        notInterestedButton.click();
        console.log('‚úÖ Not interested clicked successfully');
        await this.delay(500);
        return true;
      } else {
        console.log('‚ùå "Not interested" option not found');
        console.log('Available options:', menuItems.map(item => `"${item.textContent.trim()}"`));
        document.body.click(); // Men√ºy√º kapat
        return false;
      }
      
    } catch (error) {
      console.error('‚ùå performNotInterested error:', error);
      try {
        document.body.click(); // Men√ºy√º kapat
      } catch (e) {}
      return false;
    }
  }

  // üÜï Geli≈ütirilmi≈ü Natural i≈ülemler - Bu kanalƒ± √∂nerme (Shorts destekli)
  async performDontRecommendChannel(videoElement) {
    const analysis = this.analyzeVideoElement(videoElement);
    
    // Shorts i√ßin √∂zel i≈ülem gerekebilir ama ≈üimdilik normal metod kullanƒ±yoruz
    try {
      const menuButton = await this.findMenuButton(videoElement);
      
      if (!menuButton) {
        console.log('‚ùå Menu button not found for channel action');
        return false;
      }
      
      menuButton.click();
      console.log('üîò Menu button clicked for channel');
      
      try {
        await this.waitForElement('[role="menuitem"]', 4000);
      } catch (error) {
        console.log('‚ùå Menu items not loaded for channel action');
        document.body.click();
        return false;
      }
      
      const menuItems = Array.from(document.querySelectorAll('[role="menuitem"], [role="option"], .ytd-menu-service-item-renderer'));
      console.log('üîç Channel menu items:', menuItems.map(item => item.textContent.trim()));
      
      // "Bu kanalƒ± √∂nerme" / "Don't recommend channel" se√ßeneƒüini bul
      const dontRecommendTexts = [
        "Don't recommend channel",
        "don't recommend channel",
        "Don't recommend this channel",
        "Hide videos from this channel",
        'Bu kanalƒ± √∂nerme',
        'kanalƒ± √∂nerme',
        'Block channel',
        'Hide channel'
      ];
      
      let dontRecommendButton = null;
      for (const text of dontRecommendTexts) {
        dontRecommendButton = menuItems.find(item => 
          item.textContent.toLowerCase().includes(text.toLowerCase())
        );
        
        if (dontRecommendButton) {
          console.log(`‚úÖ "Don't recommend channel" found: "${text}"`);
          break;
        }
      }
      
      if (dontRecommendButton) {
        dontRecommendButton.click();
        console.log('‚úÖ Don\'t recommend channel clicked successfully');
        await this.delay(500);
        return true;
      } else {
        console.log('‚ùå "Don\'t recommend channel" option not found');
        console.log('Available channel options:', menuItems.map(item => `"${item.textContent.trim()}"`));
        document.body.click(); // Men√ºy√º kapat
        return false;
      }
      
    } catch (error) {
      console.error('‚ùå performDontRecommendChannel error:', error);
      try {
        document.body.click();
      } catch (e) {}
      return false;
    }
  }

  // üÜï Debug men√º √∂ƒüelerini listele (Sorun giderme i√ßin)
  async debugMenuItems(videoElement) {
    try {
      const menuButton = await this.findMenuButton(videoElement);
      if (menuButton) {
        menuButton.click();
        await this.waitForElement('[role="menuitem"]', 2000);
        
        const menuItems = Array.from(document.querySelectorAll('[role="menuitem"], [role="option"], .ytd-menu-service-item-renderer'));
        console.log('üîç Available menu items:');
        menuItems.forEach((item, index) => {
          console.log(`${index + 1}. "${item.textContent.trim()}"`);
        });
        
        // Men√ºy√º kapat
        document.body.click();
      }
    } catch (error) {
      console.error('Debug menu error:', error);
    }
  }

  // üÜï Natural i≈ülemler ana metodu (Shorts destekli)
  async performNaturalActions(options = {}) {
    const { hideShorts } = options;
    const videos = this.getVideoElements();
    const filteredVideos = videos.filter(video => {
      const language = video.getAttribute('data-language');
      const analysis = this.analyzeVideoElement(video);
      if (hideShorts && analysis.videoType === 'SHORTS') return false;
      return language && language !== 'en' && language !== 'unknown';
    });
    let processedCount = 0;
    let errorCount = 0;
    let partialCount = 0;
    let shortsMenuYokCount = 0;
    let normalMenuYokCount = 0;
    let shortsMenuYokTitles = [];
    let normalMenuYokTitles = [];
    const totalVideos = filteredVideos.length;
    this.sendProgressUpdate(0, totalVideos, 'Video analizi yapƒ±lƒ±yor...', {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
    if (totalVideos === 0) {
      this.sendProgressUpdate(0, 0, 'Filtrelenen video bulunamadƒ±', {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
      return { processed: 0, errors: 0, partial: 0, shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles };
    }
    for (let i = 0; i < filteredVideos.length; i++) {
      const videoElement = filteredVideos[i];
      try {
        const videoData = this.extractVideoData(videoElement);
        const videoTitle = videoData?.title || 'Ba≈ülƒ±k bulunamadƒ±';
        const analysis = this.analyzeVideoElement(videoElement);
        this.sendProgressUpdate(i, totalVideos, `Analiz: ${videoTitle.substring(0, 25)}...`, {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
        if (!analysis.hasMenuButton) {
          if (analysis.videoType === 'SHORTS') {
            shortsMenuYokCount++;
            shortsMenuYokTitles.push(videoTitle);
          } else {
            normalMenuYokCount++;
            normalMenuYokTitles.push(videoTitle);
          }
          this.sendProgressUpdate(i + 1, totalVideos, `‚ùå Men√º yok: ${i + 1}/${totalVideos}`, {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
          continue;
        }
        const waitTime = analysis.videoType === 'SHORTS' ? 4000 : 3000;
        await this.delay(waitTime);
        this.sendProgressUpdate(i, totalVideos, `"Not interested" i≈üleniyor...`, {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
        const notInterestedResult = await this.performNotInterested(videoElement);
        if (notInterestedResult) {
          await this.delay(1500);
          this.sendProgressUpdate(i, totalVideos, `"Don't recommend" i≈üleniyor...`, {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
          const channelResult = await this.performDontRecommendChannel(videoElement);
          if (channelResult) {
            processedCount++;
            this.sendProgressUpdate(i + 1, totalVideos, `‚úÖ Tam ba≈üarƒ±lƒ±: ${processedCount}/${totalVideos}`, {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
          } else {
            partialCount++;
            this.sendProgressUpdate(i + 1, totalVideos, `‚ö†Ô∏è Kƒ±smi ba≈üarƒ±lƒ±: ${processedCount + partialCount}/${totalVideos}`, {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
          }
        } else {
          errorCount++;
          this.sendProgressUpdate(i + 1, totalVideos, `‚ùå Ba≈üarƒ±sƒ±z: ${errorCount}/${totalVideos}`, {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
        }
      } catch (error) {
        errorCount++;
        this.sendProgressUpdate(i + 1, totalVideos, `‚ùå Hata: ${error.message.substring(0, 20)}...`, {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
      }
      await this.delay(1000);
    }
    const successRate = Math.round(((processedCount + partialCount) / totalVideos) * 100);
    this.sendProgressUpdate(totalVideos, totalVideos, `üéâ Tamamlandƒ±! %${successRate} ba≈üarƒ± (${processedCount} tam, ${partialCount} kƒ±smi, ${errorCount} hata)`, {shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles});
    return { processed: processedCount, errors: errorCount, partial: partialCount, shortsMenuYokCount, normalMenuYokCount, shortsMenuYokTitles, normalMenuYokTitles };
  }

  // üÜï Progress mesajƒ± g√∂nderme metodu
  sendProgressUpdate(current, total, message, extraStats) {
    try {
      chrome.runtime.sendMessage({
        action: 'naturalProgress',
        current: current,
        total: total,
        message: message,
        shortsMenuYokCount: extraStats?.shortsMenuYokCount || 0,
        normalMenuYokCount: extraStats?.normalMenuYokCount || 0,
        shortsMenuYokTitles: extraStats?.shortsMenuYokTitles || [],
        normalMenuYokTitles: extraStats?.normalMenuYokTitles || []
      });
    } catch (error) {
      // Silent error - popup might not be open
      console.log(`üìä Progress: ${current}/${total} - ${message}`);
    }
  }

  // üÜï Yardƒ±mcƒ± fonksiyonlar
  async waitForElement(selector, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const element = document.querySelector(selector);
      if (element) {
        resolve(element);
        return;
      }

      const observer = new MutationObserver(() => {
        const element = document.querySelector(selector);
        if (element) {
          observer.disconnect();
          resolve(element);
        }
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true
      });

      setTimeout(() => {
        observer.disconnect();
        reject(new Error(`Element ${selector} not found within ${timeout}ms`));
      }, timeout);
    });
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}